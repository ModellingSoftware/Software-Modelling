// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ROVU;

import javax.vecmath.Vector3d;
import javax.vecmath.*;

import simbad.sim.Agent;
import simbad.sim.RobotFactory;

/************************************************************/
/**
 * 
 */
public abstract class Rover extends Agent{
	
    public Rover(Vector3d position, String name) {
        super(position, name);
        // Add bumpers
        RobotFactory.addBumperBeltSensor(this, 1);
        // Add sonars
        RobotFactory.addSonarBeltSensor(this, 1);       
        
        speed = 0.5f;
        lastCollisionFreePos = null;   
    }

	/**
	 * 
	 */
	private int id;
	/**
	 * 
	 */
	private float speed;
	/**
	 * 
	 */
	private int direction;
	/**
	 * 
	 */
	private Vector3d position;
	/**
	 * 
	 */
	private float maxSpeed;
	/**
	 * 
	 */
	private boolean active;
	
	private Vector3d lastCollisionFreePos;
	/**
	 * 
	 * @return
	 */
	public int getId() {
		return id;
	}

	/**
	 * 
	 * @return
	 */
	public void setId(int id) {
		this.id = id;
	}

	/**
	 * 
	 * @return
	 */
	public float getSpeed() {
		return speed;
	}

	/**
	 * 
	 * @return
	 */
	public void setSpeed(float speed) {
		this.speed = speed;
	}

	/**
	 * 
	 * @return
	 */
	public int getDirection() {
		return direction;
	}

	/**
	 * 
	 * @return
	 */
	public void setDirection(int direction) {
		this.direction = direction;
	}

	/**
	 * 
	 * @return
	 */
	public Vector3d getPosition() {
		Point3d newPoint = new Point3d();
		this.getCoords(newPoint);
		
		return new Vector3d(newPoint.x, newPoint.y, newPoint.z);
	}

	/**
	 * 
	 * @return
	 */
	public void setPosition(Vector3D position) {
		this.position = position;
	}

	/**
	 * 
	 * @return
	 */
	public float getMaxSpeed() {
		return maxSpeed;
	}

	/**
	 * 
	 * @return
	 */
	public void setMaxSpeed(float maxSpeed) {
		this.maxSpeed = maxSpeed;
	}

	/**
	 * 
	 * @return
	 */
	public boolean isActive() {
		return active;
	}

	/**
	 * 
	 * @return
	 */
	public void setActive(boolean active) {
		this.active = active;
	}

	/**
	 * 
	 * @return
	 */
	public RoverType getType() {
		return type;
	}

	/**
	 * 
	 * @return
	 */

	/**
	 * 
	 * @return
	 */
	public CentralStation getCentralStation() {
		return centralStation;
	}

	/**
	 * 
	 * @return
	 */
	public void setCentralStation(CentralStation centralStation) {
		this.centralStation = centralStation;
	}

	/**
	 * 
	 */
	private RoverType type;
	
	/**
	 * 
	 */
	private CentralStation centralStation;

	/**
	 * 
	 * @param direction 
	 */
	public void moveInDirection(int direction) {
	}

	/**
	 * 
	 * @param Coordinate 
	 */
	public void moveToCoordinate(Vector3D Coordinate) {
	}

	/**
	 * 
	 */
	public void turnOff() {
	}
	

	private String currentMode;

    /** This method is called by the simulator engine on reset. */
    public void initBehavior() {
        System.out.println("I exist and my name is " + this.name);
        setRotationalVelocity(Math.PI / 2 * (0.5 - Math.random()));
    }

    /** This method is call cyclically (20 times per second) by the simulator engine. */
    public void performBehavior() {
    	Rover collidingRover = null;
    	// perform the following actions every 5 virtual seconds
    	if(this.getCounter() % 5 == 0) {    		
    		if(this.getVeryNearAgent() != null) {
    			collidingRover = (Rover) this.getVeryNearAgent();
    			this.currentMode = "avoidRover";
    		} else if(this.collisionDetected()) {
	    		this.currentMode = "avoidObstacle";
	    	} else {
	    		this.currentMode = "moveForward";
	    	}
	        
	    	if(this.currentMode.equals("moveForward")) {
	    		
	        	setRotationalVelocity(0);
	    		// the robot's speed is always 0.5 m/s
	            this.setTranslationalVelocity(speed);
	        } else if(this.currentMode.equals("avoidRover")) {
	        	//if (collidingRover.currentMode.equals("avoidRover")) {
	        	//}
	        	//this.setTranslationalVelocity(collidingRover.getTranslationalVelocity() - 0.1);
	        	// don't move
	        	this.setTranslationalVelocity(-speed);
	        	// rotate only until obstacle is not there
	        	setRotationalVelocity(Math.PI / 1);
	        } else {
	        	// don't move
	        	this.setTranslationalVelocity(-speed);
	        	// rotate only until obstacle is not there
	        	setRotationalVelocity(Math.PI / 1);
	        }
    	}
    	
    }
};
