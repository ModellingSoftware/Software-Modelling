// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ROVU;

import javax.vecmath.Vector3d;
import javax.vecmath.*;

import simbad.sim.Agent;
import simbad.sim.RobotFactory;

/************************************************************/
/**
 * 
 */
public abstract class Rover extends Agent{
	
    public Rover(Vector3d position, String name) {
        super(position, name);
        // Add bumpers
        RobotFactory.addBumperBeltSensor(this, 1);
        // Add sonars
        RobotFactory.addSonarBeltSensor(this, 1);       
        
        active = false;
        speed = 0.5f;
        maxSpeed = .05f;
        lastCollisionFreePos = null;   
        currentDirection = Directions.North;
        //setSpawnRotation(); 
    }

	/**
	 * 
	 */
	private int id;
	/**
	 * 
	 */
	private float speed;
	/**
	 * 
	 */
	private Directions currentDirection;
	/**
	 * 
	 */
	private Vector3d position;
	/**
	 * 
	 */
	private float maxSpeed;
	/**
	 * 
	 */
	private boolean active;
	
	private Vector3d lastCollisionFreePos;
	
	private String currentMode;
	

	/**
	 * 
	 */
	private RoverType type;
	
	/**
	 * 
	 */
	private CentralStation centralStation;

	/**
	 * 
	 * @return
	 */
	public int getId() {
		return id;
	}

	/**
	 * 
	 * @return
	 */
	public void setId(int id) {
		this.id = id;
	}

	/**
	 * 
	 * @return
	 */
	public float getSpeed() {
		return speed;
	}

	/**
	 * 
	 * @return
	 */
	public void setSpeed(float speed) {
		this.speed = speed;
	}

	/**
	 * 
	 * @return
	 */
	public Directions getDirection() {
		return direction;
	}

	/**
	 * 
	 * @return
	 */
	public void setDirection(Directions dir) {
		this.direction = dir;
	}

	/**
	 * 
	 * @return
	 */
	public Vector3d getPosition() {
		Point3d newPoint = new Point3d();
		this.getCoords(newPoint);
		
		return new Vector3d(newPoint.x, newPoint.y, newPoint.z);
	}

	/**
	 * 
	 * @return
	 */
	public void setPosition(Vector3d position) {
		this.position = position;
	}

	/**
	 * 
	 * @return
	 */
	public float getMaxSpeed() {
		return maxSpeed;
	}

	/**
	 * 
	 * @return
	 */
	public void setMaxSpeed(float maxSpeed) {
		this.maxSpeed = maxSpeed;
	}

	/**
	 * 
	 * @return
	 */
	public boolean isActive() {
		return active;
	}

	/**
	 * 
	 * @return
	 */
	public void setActive(boolean active) {
		this.active = active;
	}
	
	public String getCurrentMode() {
		return currentMode;
	}

	public void setCurrentMode(String curMod) {
		currentMode = curMod;
	}
	
	/**
	 * 
	 * @return
	 * 
	 */
	public RoverType getType() {
		return type;
	}

	/**
	 * 
	 * @return
	 */

	/**
	 * 
	 * @return
	 */
	public CentralStation getCentralStation() {
		return centralStation;
	}

	/**
	 * 
	 * @return
	 */
	public void setCentralStation(CentralStation centralStation) {
		this.centralStation = centralStation;
	}

	/**
	 * 
	 * @param direction 
	 */
	public void moveInDirection(int direction) {
	}

	/**
	 * 
	 * @param Coordinate 
	 */
	public void moveToCoordinate(Vector3D Coordinate) {
	}

	public void setSpawnRotation() {
		switch (direction) {

		case North:		rotateY(Math.PI * (1 / 2));
						break;
		
		case NorthEast: rotateY(Math.PI * (1 / 4));
						break;

		case East: 		rotateY(0);
						break;

		case SouthEast: rotateY(Math.PI * -(1 / 4));
						break;

		case South: 	rotateY(Math.PI * -(1 / 2));
						break;

		case SouthWest:	rotateY(Math.PI * -(3 / 4));
						break;

		case West: 		rotateY(Math.PI);
						break;

		case NorthWest:	rotateY(Math.PI * (3 / 4));
						break;
		}
	}

		public void setSpawnRotation() {
		switch (direction) {

		case North:		rotateY(Math.PI * (1 / 2));
						break;
		
		case NorthEast: rotateY(Math.PI * (1 / 4));
						break;

		case East: 		rotateY(0);
						break;

		case SouthEast: rotateY(Math.PI * -(1 / 4));
						break;

		case South: 	rotateY(Math.PI * -(1 / 2));
						break;

		case SouthWest:	rotateY(Math.PI * -(3 / 4));
						break;

		case West: 		rotateY(Math.PI);
						break;

		case NorthWest:	rotateY(Math.PI * (3 / 4));
						break;
		}
	}

	private void changeRelativeDirection(String direction){
    	switch(direction){
    	
    	case "Left":
    		rotateY(Math.PI / 2); 
    		switch(this.currentDirection){
    		case South:
    			this.currentDirection = Directions.East;
    			break;
    		case West:
    			this.currentDirection = Directions.South;
    			break;
    		case North:
    			this.currentDirection = Directions.West;
    			break;
    		case East:
    			this.currentDirection = Directions.North;
    			break;
			default:
				break;
    		}
    		break;
    		
    	case "Right":
    		rotateY(-Math.PI/2);
    		switch(this.currentDirection){
    		case South:
    			this.currentDirection = Directions.West;
    			break;
    		case West:
    			this.currentDirection = Directions.North;
    			break;
    		case North:
    			this.currentDirection = Directions.East;
    			break;
    		case East:
    			this.currentDirection = Directions.South;
    			break;
			default:
				break;
    		}
    		break;
    		
    	case "Back":
    		rotateY(-Math.PI);
    		switch(this.currentDirection){
    		case South:
    			this.currentDirection = Directions.North;
    			break;
    		case West:
    			this.currentDirection = Directions.East;
    			break;
    		case North:
    			this.currentDirection = Directions.South;
    			break;
    		case East:
    			this.currentDirection = Directions.West;
    			break;
			default:
				break;
    		}
    		break;
    	}
    }
    
    private void changeAbsoluteDirection(Directions direction){
    	switch(direction){
    	
    	case North:
    		
    		switch(this.currentDirection){
    		
    		case South:
    			changeRelativeDirection("Back");
    			break;
    			
    		case West:
    			changeRelativeDirection("Right");
    			break;
    			
    		case East:
    			changeRelativeDirection("Left");
    			break;
    			
			default:
				break;
    		}
    		
    		break;
    		
    	case West:
    		
    		switch(this.currentDirection){
    		
    		case South:
    			changeRelativeDirection("Right");
    			break;
    			
    		case North:
    			changeRelativeDirection("Left");
    			break;
    			
    		case East:
    			changeRelativeDirection("Back");
    			break;
    			
			default:
				break;
    		}
    		
    		break;
    		
    	case South:
    		
    		switch(this.currentDirection){
    		
    		case West:
    			changeRelativeDirection("Left");
    			break;
    			
    		case North:
    			changeRelativeDirection("Back");
    			break;
    			
    		case East:
    			changeRelativeDirection("Right");
    			break;
    			
			default:
				break;
    		}
    		
    		break;
    		
    	case East:
    		
    		switch(this.currentDirection){
    		
    		case South:
    			changeRelativeDirection("Left");
    			break;
    			
    		case West:
    			changeRelativeDirection("Back");
    			break;
    			
    		case North:
    			changeRelativeDirection("Right");
    			break;
    			
			default:
				break;
    		}
    		
    		break;
    	
    	}

    	

    	
    }
	/**
	 * 
	 */
	public void turnOff() {
	}
	
    /** This method is called by the simulator engine on reset. */
    public void initBehavior() {
        System.out.println("I exist and my name is " + this.name);
        setSpawnRotation();
    }

    /** This method is call cyclically (20 times per second) by the simulator engine. */
    public void performBehavior() {
    	if (active) {
	    	Rover collidingRover = null;
	    	// perform the following actions every 5 virtual seconds
	    	if(this.getCounter() % 5 == 0) {    		
	    		if(this.getVeryNearAgent() != null) {
	    			collidingRover = (Rover) this.getVeryNearAgent();
	    			this.currentMode = "avoidRover";
	    		} else if(this.collisionDetected()) {
		    		this.currentMode = "avoidObstacle";
		    	} else {
		    		this.currentMode = "moveForward";
		    	}
		        /**
		    	if(this.currentMode.equals("moveForward")) {
		        	setRotationalVelocity(0);
		    		// the robot's speed is always 0.5 m/s
		            this.setTranslationalVelocity(speed);
		        } else if(this.currentMode.equals("avoidRover")) {
		        	//if (collidingRover.currentMode.equals("avoidRover")) {
		        	//}
		        	//this.setTranslationalVelocity(collidingRover.getTranslationalVelocity() - 0.1);
		        	// don't move
		        	this.setTranslationalVelocity(-speed);
		        	// rotate only until obstacle is not there
		        	setRotationalVelocity(Math.PI / 1);
		        } else {
		        	// don't move
		        	this.setTranslationalVelocity(-speed);
		        	// rotate only until obstacle is not there
		        	setRotationalVelocity(Math.PI / 1);
		        }
		        **/
	    	}
    	}
    }
};
