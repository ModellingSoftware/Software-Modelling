// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package rovuClassDiagram1.ROVU;

import javax.vecmath.Vector3d;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.ArrayList;
import java.util.HashMap;



/************************************************************/
/**
 * 
 */



public class mapObject {
	/**
	 * 
	 */
	public Vector3D[] section;
	/**
	 * 
	 */
	public Vector3D[] obstaclesArray;
	
	int sectionID;
	int[][] map;
	
	mapObject(int width, int height){
		map = new int[width][height];
		for(int i=0; i<width; i++){
			for(int j=0; j<height;j++){
				//Unknown spot
				map[i][j]=0;
			}
		}
	}
	
	public void placeObstacle(Coordinate c){
		map[c.getx()][c.gety()]=-1;
	}

	public void placeFreeSpace(Coordinate c){
		map[c.getx()][c.gety()]=1;
	}
	
	public ArrayList<Coordinate> getNeighbors(Coordinate c){
		int x=c.getx(), y=c.gety();
		
		ArrayList<Coordinate> listOfNeighbors = new ArrayList<Coordinate>();
		
		//Check left
		if(x!=0 && map[x-1][y]==1){
			listOfNeighbors.add(new Coordinate(x-1, y));
		}
		
		//Check top
		if(y!=0 && map[x][y-1] == 1){
			listOfNeighbors.add(new Coordinate(x, y-1));
		}
		
		//Check right
		if(x!=map.length-1 && map[x+1][y] == 1){
			listOfNeighbors.add(new Coordinate(x+1, y));
		}
		
		//Check below
		if(y!=map[0].length-1 && map[x][y+1] == 1){
			listOfNeighbors.add(new Coordinate(x, y+1));
		}
		
		return listOfNeighbors;
	}
	
	public double heuristic(Coordinate goal, Coordinate start){
		return Math.sqrt( Math.pow(goal.getx()-start.getx(), 2) + Math.pow(goal.gety()-start.gety(), 2) );
	}
	
	public ArrayList<Coordinate> getPath(Coordinate start, Coordinate goal){
		
		PriorityQueue<CoordinateWithPriority> frontier = new PriorityQueue<CoordinateWithPriority>();
		frontier.add(new CoordinateWithPriority(start, 0));
		
		HashMap<Coordinate, Coordinate> cameFrom	= new HashMap<Coordinate, Coordinate>();
		HashMap<Coordinate, Integer> costSoFar		= new HashMap<Coordinate, Integer>();
		
		cameFrom.put(start, null);
		costSoFar.put(start, 0);
		
		while(!frontier.isEmpty()){
			Coordinate current = frontier.remove().coordinate;
			
			if(current.equals(goal)){
				break;
			}
			
			for(Coordinate next:getNeighbors(current)){
				int new_cost = costSoFar.get(current) + 1;
				
				if(!costSoFar.containsKey(next) || new_cost < costSoFar.get(next)){
					costSoFar.put(next, new_cost);
					
					double priority = new_cost + (heuristic(goal, next));
					frontier.add(new CoordinateWithPriority(next, priority));
					
					cameFrom.put(next, current);
				}
			}
		}
		
		ArrayList<Coordinate> shortestPath = new ArrayList<Coordinate>();
		
		
		Coordinate current = goal;
		
		do {
			shortestPath.add(current);
			current = cameFrom.get(current);
		} while(current != null);
		
		Collections.reverse(shortestPath);
		
		return shortestPath;
		
		
		
	}
	

};
